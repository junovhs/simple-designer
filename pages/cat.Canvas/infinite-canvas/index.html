<!DOCTYPE html>
<html>
<head>
    <style>
        #infinite-canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #f0f0f0; overflow: hidden; }
        #svg-canvas { background: white; }
        .grid { stroke: rgba(0,0,0,0.1); stroke-width: 1; vector-effect: non-scaling-stroke; }
        .tick { stroke: rgba(0,0,0,0.2); stroke-width: 1.5; }
        /* Snapping helpers (visual) */
        .snap-guide { stroke: red; stroke-width: 1; stroke-dasharray: 5; opacity: 0.5; }
    </style>
</head>
<body>
    <!-- module: {"id": "infinite-canvas", "slots": ["#canvas-center"], "hooks": ["init"]} -->
    <div id="infinite-canvas-container">
        <svg id="svg-canvas" width="100%" height="100%" viewBox="0 0 100 100">
            <!-- Grid drawn dynamically -->
        </svg>
    </div>
    <script>
        // Infinite Canvas Module
        window.infiniteCanvas = {
            init: function({ bus, store }) {
                const container = document.getElementById('infinite-canvas-container');
                const svg = document.getElementById('svg-canvas');
                
                // Sync store viewBox
                function updateViewBox() {
                    const vb = store.get('viewBox') || { x: 0, y: 0, width: 100, height: 100 };
                    svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
                    drawGrid();
                }
                
                // Draw faint grid (10x10 units, ticks every 50)
                function drawGrid() {
                    const vb = store.get('viewBox');
                    svg.innerHTML = ''; // Clear for redraw (perf: only visible area)
                    
                    const gridSize = 10;
                    const tickSize = 50;
                    const startX = Math.floor(vb.x / gridSize) * gridSize;
                    const endX = Math.ceil((vb.x + vb.width) / gridSize) * gridSize;
                    const startY = Math.floor(vb.y / gridSize) * gridSize;
                    const endY = Math.ceil((vb.y + vb.height) / gridSize) * gridSize;
                    
                    for (let x = startX; x <= endX; x += gridSize) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', vb.y);
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', vb.y + vb.height);
                        line.classList.add('grid');
                        if (x % tickSize === 0) line.classList.add('tick');
                        svg.appendChild(line);
                    }
                    for (let y = startY; y <= endY; y += gridSize) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', vb.x);
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', vb.x + vb.width);
                        line.setAttribute('y2', y);
                        line.classList.add('grid');
                        if (y % tickSize === 0) line.classList.add('tick');
                        svg.appendChild(line);
                    }
                }
                
                // Enhanced zoom: Around mouse, snap to 1px
                svg.addEventListener('wheel', e => {
                    e.preventDefault();
                    const rect = svg.getBoundingClientRect();
                    const mouseX = (e.clientX - rect.left) / rect.width;
                    const mouseY = (e.clientY - rect.top) / rect.height;
                    let vb = store.get('viewBox');
                    const scale = e.deltaY < 0 ? 1.1 : 0.9;
                    const newWidth = vb.width * scale;
                    const newHeight = vb.height * scale;
                    vb.x = vb.x + (mouseX * vb.width) - (mouseX * newWidth);
                    vb.y = vb.y + (mouseY * vb.height) - (mouseY * newHeight);
                    vb.width = Math.max(1, Math.round(newWidth)); // Snap min 1px
                    vb.height = Math.max(1, Math.round(newHeight));
                    store.set('viewBox', vb);
                }, { passive: false });
                
                // Pan with space or middle drag
                let isPanning = false, lastX, lastY, keys = {};
                document.addEventListener('keydown', e => { keys[e.key] = true; });
                document.addEventListener('keyup', e => { keys[e.key] = false; });
                svg.addEventListener('mousedown', e => {
                    if (e.button === 1 || keys[' ']) { // Middle or space
                        isPanning = true;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        svg.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });
                document.addEventListener('mousemove', e => {
                    if (isPanning) {
                        let vb = store.get('viewBox');
                        const deltaX = (e.clientX - lastX) * (vb.width / svg.clientWidth);
                        const deltaY = (e.clientY - lastY) * (vb.height / svg.clientHeight);
                        vb.x = Math.round(vb.x - deltaX); // Snap pan to px
                        vb.y = Math.round(vb.y - deltaY);
                        store.set('viewBox', vb);
                        lastX = e.clientX;
                        lastY = e.clientY;
                    }
                });
                document.addEventListener('mouseup', () => {
                    isPanning = false;
                    svg.style.cursor = 'default';
                });
                
                // Listen for store changes (e.g., external viewBox updates)
                store.onChange(updateViewBox);
                
                // Emit canvas events
                bus.on('canvasClick', detail => {
                    // Future: Add shapes/text at click
                    console.log('Canvas clicked at', detail.x, detail.y);
                });
                
                // Initial draw
                updateViewBox();
                
                // Expose for other modules
                window.canvasAPI = { svg, updateViewBox, drawGrid };
                
                console.log('Infinite Canvas module initialized');
            }
        };
    </script>
</body>
</html>